
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable

#include "BRDF.glsl"
#include "common.glsl"


layout(set = 0, binding = 0) uniform  CameraBuffer{
	mat4 viewMatrix;
	mat4 inverseViewMatrix;
  mat4 projectionMatrix;
  mat4 inverseProjectionMatrix;
	vec3 cameraPosition;
} cameraData;

layout(set = 0, binding = 1) uniform  RenderBuffer{
	float fog;
	uint sunLightCount;
	uint pointLightCount;
	uint spotLightCount;
  uint maxRecoursionDepth;
  uint maxDiffuseSampleCount;
  uint maxSpecularSampleCount;
  uint maxShadowRaySampleCount;
  uint noiseSampleTextureIndex;
  uint sampleSequenceLength;
  uint frameNumber;
  uint historyLength;
	uint historyIndex;
	uint nativeResolutionWidth;
	uint nativeResolutionHeight;
} globalDrawData;


layout(set = 1, binding = 0) uniform sampler2D primaryRayUnlitColorTexture;
layout(set = 1, binding = 1) uniform sampler2D primaryRayNormalTexture;
layout(set = 1, binding = 2) uniform sampler2D primaryRayDepthTexture;
layout(set = 1, binding = 3) uniform sampler2D primaryRayRoughnessMetalicTexture;
layout(set = 1, binding = 4) uniform sampler2D primaryRayPositionTexture;

layout(set = 2, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 2, binding = 1, rgba32f) uniform image3D image;
layout(std430, set = 2, binding = 4) readonly buffer sampleSequenceBuffer{
  vec2 samples[];
} sampleSequence;

layout(std430, set = 3, binding = 0) readonly buffer SunBuffer{
	SunLight sunLights[];
} sunLightBuffer;

layout(std430, set = 3, binding = 1) readonly buffer PointBuffer{
	PointLight pointLights[];
} pointLightBuffer;

layout(std430, set = 3, binding = 2) readonly buffer SpotBuffer{
	SpotLight spotLights[];
} spotLightBuffer; 

layout(set = 4, binding = 0) uniform sampler albedoSampler;
layout(set = 4, binding = 1) uniform sampler metallicSampler;
layout(set = 4, binding = 2) uniform sampler normalSampler;
layout(set = 4, binding = 3) uniform sampler roughnessSampler;

layout(std430, set = 5, binding = 0) readonly buffer DrawInstanceBuffer{
	drawInstanceData instanceData[];
} drawData;

layout(set = 6, binding = 0) uniform texture2D textures[1024]; 

struct hitPayload
{
  bool miss;
  vec3 radiance;
  uint depth;
};

layout(location = 1) rayPayloadEXT hitPayload payload;
layout(location = 0) rayPayloadEXT float shadowPayload;

void main()
{
  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  
  vec4 unlitColor = texture(primaryRayUnlitColorTexture, inUV);
  vec4 normal = texture(primaryRayNormalTexture, inUV);
  float depth = texture(primaryRayDepthTexture, inUV).x;
  vec4 roughnessMetalness = texture(primaryRayRoughnessMetalicTexture, inUV);
  vec4 samplePosition =  texture(primaryRayPositionTexture, inUV);

  normal.xyz = normalize(normal.xyz);
	float reflectance = 0.04;	
	float roughness = roughnessMetalness.x;
	float metallic = roughnessMetalness.y;
  

  vec3 viewDirection = normalize(cameraData.cameraPosition - samplePosition.xyz);
  uint  rayFlags = gl_RayFlagsOpaqueEXT;
  uint  shadowRayFlags =  gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT;
  float tMin     = 0.01;
  float tMax     = 1000.0;
  
  vec2 offset = vec2(float((globalDrawData.frameNumber) % globalDrawData.historyLength)) 
      / vec2(float(globalDrawData.nativeResolutionWidth), float(globalDrawData.nativeResolutionHeight));
  vec4 screenNoise = texture(sampler2D(textures[globalDrawData.noiseSampleTextureIndex], albedoSampler), inUV * vec2(1920.0/1024.0, 1080.0/1024.0) + offset);
  
  vec4 outColor = vec4(0.0, 0.0, 0.0, 1.0);
  
  vec3 radiance = vec3(0.0, 0.0, 0.0);
  for(uint i = 0; i < globalDrawData.pointLightCount; i++)
  {
    vec3 lightDirection = pointLightBuffer.pointLights[i].position - samplePosition.xyz;
    float distance = length(lightDirection);
    lightDirection = normalize(lightDirection);
    float cosTheta = dot(lightDirection, normal.xyz);
    
    for(uint s = 0; s < globalDrawData.maxShadowRaySampleCount; s++)
    {
      shadowPayload = 0.0;

      vec4 noise = texture(sampler2D(textures[globalDrawData.noiseSampleTextureIndex], albedoSampler), screenNoise.xy + vec2(float(s) 
      / vec2(float(globalDrawData.nativeResolutionWidth), float(globalDrawData.nativeResolutionHeight))));
      
      float radius = pointLightBuffer.pointLights[i].radius;
      vec3 lightSampleDirection = normalize(createLightSampleVector(lightDirection, radius, noise.x, noise.y));
      
      vec3 lightNormal = normalize(lightSampleDirection - (dot(lightDirection*distance, lightSampleDirection) * lightDirection * distance));
      float area = 3*M_PI*pow(radius, 2.0);
      float p = max(dot(-lightSampleDirection, lightNormal), 0.0);

      traceRayEXT(topLevelAS, // acceleration structure
      shadowRayFlags,       // rayFlags
      0xFF,           // cullMask
      0,              // sbtRecordOffset
      0,              // sbtRecordStride
      1,              // missIndex
      samplePosition.xyz,     // ray origin
      tMin,           // ray min range
      lightSampleDirection,  // ray direction
      distance,           // ray max range
      0               // payload (location = 0)
      );
      vec3 lightColor = normalize(pointLightBuffer.pointLights[i].color.xyz);
	    float attenuation = 1.0/(distance*distance);
	    vec3 brdf = cookTorranceGgxBRDF(viewDirection, lightSampleDirection, normal.xyz, unlitColor.xyz, metallic, roughness, reflectance);
      vec3 lightRadiance = lightColor * vec3(pointLightBuffer.pointLights[i].strength * max(cosTheta, 0.0) * attenuation * shadowPayload * p * area);
	    radiance =  radiance +  brdf * lightRadiance;
    }
    
  }  
  radiance = radiance / float(globalDrawData.pointLightCount);

  for(uint i = 0; i < globalDrawData.sunLightCount; i++)
  {
    shadowPayload = 0.0;
    vec3 lightDirection = -sunLightBuffer.sunLights[i].direction;
    float range = tMax;
    lightDirection = normalize(lightDirection);
    
    float cosTheta = dot(lightDirection, normal.xyz);
    traceRayEXT(topLevelAS, // acceleration structure
    shadowRayFlags,       // rayFlags
    0xFF,           // cullMask
    0,              // sbtRecordOffset
    0,              // sbtRecordStride
    1,              // missIndex
    samplePosition.xyz,     // ray origin
    tMin,           // ray min range
    lightDirection.xyz,  // ray direction
    tMax,           // ray max range
    0               // payload (location = 0)
    );

    vec3 lightColor = normalize(sunLightBuffer.sunLights[i].color.xyz);

	  vec3 brdf = cookTorranceGgxBRDF(viewDirection, lightDirection, normal.xyz, unlitColor.xyz, metallic, roughness, reflectance) * shadowPayload;
	  radiance =  radiance + max(cosTheta, 0.0) * brdf * sunLightBuffer.sunLights[i].strength * lightColor;
  }


  payload.radiance = vec3(radiance);
  
  payload.depth = 1;

  vec3 diffuseRadiance = vec3(0.0);
  
  vec3 w = vec3(0.0);

  for(uint i = 0; i < globalDrawData.maxDiffuseSampleCount; i++)
  {
    /* uint index = (i + globalDrawData.frameNumber) % globalDrawData.sampleSequenceLength;
    vec2 noise = sampleSequence.samples[index]; */
    
    vec4 noise = texture(sampler2D(textures[globalDrawData.noiseSampleTextureIndex], albedoSampler), screenNoise.xy + vec2(float(i) 
      / vec2(float(globalDrawData.nativeResolutionWidth), float(globalDrawData.nativeResolutionHeight))));

    float pdfValue = lambertImportancePDF(noise.x);
    float ggxPdfValue = ggxImportancePDF(noise.x, roughness);

    float weight = veachBalanceHeuristik(ggxPdfValue, pdfValue);
   
    w.x = weight;

    vec3 sampleDirection = createSampleVector(normal.xyz, 0.5 * M_PI, 2.0 * M_PI, pdfValue, noise.y);

    float cosTheta = max(dot(sampleDirection, normal.xyz), 0.0);

    traceRayEXT(topLevelAS, // acceleration structure
      rayFlags,       // rayFlags
      0xFF,           // cullMask
      0,              // sbtRecordOffset
      0,              // sbtRecordStride
      0,              // missIndex
      samplePosition.xyz,     // ray origin
      tMin,           // ray min range
      sampleDirection,  // ray direction
      tMax,           // ray max range
      1               // payload (location = 0)
      );
    diffuseRadiance = diffuseRadiance + (unlitColor.xyz * cosTheta * payload.radiance) * weight / pdfValue;
    diffuseRadiance = diffuseRadiance;
    
  }
  diffuseRadiance = diffuseRadiance / float( globalDrawData.maxDiffuseSampleCount);

  payload.radiance = vec3(radiance);

  vec3 specularRadiance = vec3(0.0);

  for(uint i = 0; i < globalDrawData.maxSpecularSampleCount; i++)
	{
    uint index = (i + globalDrawData.frameNumber) % globalDrawData.sampleSequenceLength;
    /* vec2 noise = sampleSequence.samples[index]; */

    vec4 noise = texture(sampler2D(textures[globalDrawData.noiseSampleTextureIndex], albedoSampler), screenNoise.xy + vec2(float(i) 
      / vec2(float(globalDrawData.nativeResolutionWidth), float(globalDrawData.nativeResolutionHeight))));

    float pdfValue = ggxImportancePDF(noise.x, roughness);
    float lambertPDFValue =  lambertImportancePDF(noise.x);

    float weight = veachBalanceHeuristik(lambertPDFValue, pdfValue);

    w.y = weight;

    vec3 halfwayVector = createSampleVector(normal.xyz, 0.5 * M_PI, 2.0 * M_PI, pdfValue, noise.y);

    vec3 reflectionDirection = reflect(-viewDirection, halfwayVector);

		float cosTheta = max(dot(reflectionDirection, normal.xyz), 0.0f);

		traceRayEXT(topLevelAS, // acceleration structure
        rayFlags,       // rayFlags
        0xFF,           // cullMask
        0,              // sbtRecordOffset
        0,              // sbtRecordStride
        0,              // missIndex
        samplePosition.xyz,     // ray origin
        tMin,           // ray min range
        reflectionDirection,  // ray direction
        tMax,           // ray max range
        1               // payload (location = 0)
        );

    vec3 brdf = ggxSpecularBRDF(viewDirection, reflectionDirection, normal.xyz, unlitColor.xyz, metallic, roughness, reflectance); 

    specularRadiance = specularRadiance + ( brdf * payload.radiance) * weight / pdfValue;
	} 
  specularRadiance = specularRadiance / float(globalDrawData.maxSpecularSampleCount);
	
  outColor.xyz = radiance;
  outColor.xyz = outColor.xyz + specularRadiance;
  outColor.xyz = outColor.xyz + diffuseRadiance * (1.0 - metallic);

  outColor.xyz = outColor.xyz / 3.0;

  /*  outColor.xyz = w; */

  outColor.w = depth;

  imageStore(image, ivec3(gl_LaunchIDEXT.xy, globalDrawData.historyIndex % globalDrawData.historyLength), outColor);
}